{"version":3,"sources":["webpack:///billiard-element.min.js","webpack:///webpack/bootstrap ead3daef0ca45b3d084b","webpack:///./src/billiard-element.js","webpack:///./src/billiard-touch-drive.js"],"names":["e","a","i","this","modules","__webpack_require__","moduleId","installedModules","exports","module","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","BilliardTouchDrive","prefix","div","document","createElement","style","cssText","webkitTransition","MozTransition","oTransition","msTransition","BilliardElement","el","_this","_el","position","_interval","status","_moveStatus","x","y","MAX_X","MAX_Y","FPS","speed","frictionSpeed","touchDriveCoefficient","limit","minX","maxX","minY","maxY","_config","moveAreaMarginLeft","moveAreaMarginRight","moveAreaMarginTop","moveAreaMarginBottom","_touchDrive","init","addEventListener","updateElPosition","start","move","_updateEl","moveRes","end","drive","angle","value","JSON","parse","stringify","con","arguments","undefined","config","_useConfig","moveStatus","_this2","moveAngle","movePath","_getMovePath","res","_getNextFsMoveInfo","_move","force","offsetLeft","offsetTop","body","documentElement","clientWidth","offsetWidth","clientHeight","offsetHeight","left","top","animations","resolve","_this3","fpsTime","setInterval","coorChange","pop","clearInterval","params","endSpeed","averageSpeed","_getXY","distance","Math","sin","cos","fn","push","reverse","contentWidth","attractSpeed","_x","_y","_history","_ALLOW_HISTORY","event","changedTouches","clientX","clientY","preventDefault","changeX","changeY","timeStamp","history","shift","allowHistory","last","lastPreviou","time","sqrt","atan2"],"mappings":"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","file":"billiard-element.min.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(this, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// @ts-check\nvar BilliardTouchDrive = __webpack_require__(1);\n\nvar prefix = function () {\n    var div = document.createElement('div');\n    var cssText = '-webkit-transition:all .1s; -moz-transition:all .1s; -o-transition:all .1s; -ms-transition:all .1s; transition:all .1s;';\n    div.style.cssText = cssText;\n    var style = div.style;\n    if (style.webkitTransition) {\n        return 'WebkitTransform';\n    }\n    if (style.MozTransition) {\n        return 'MozTransform';\n    }\n    if (style.oTransition) {\n        return 'oTransform';\n    }\n    if (style.msTransition) {\n        return 'msTransform';\n    }\n    return 'transform';\n}();\n\nvar BilliardElement = function () {\n    _createClass(BilliardElement, null, [{\n        key: 'create',\n        value: function create(el) {\n            return new this(el);\n        }\n    }]);\n\n    function BilliardElement(el) {\n        var _this = this;\n\n        _classCallCheck(this, BilliardElement);\n\n        this._el = el;\n        el.style.position = 'fixed';\n        this._interval = null;\n        this.status = 'uninit'; // 'uninit'|'static' | 'moving'\n        this._moveStatus = {\n            x: 0,\n            y: 0,\n            MAX_X: 0,\n            MAX_Y: 0,\n            FPS: 50,\n            speed: 0,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1,\n            limit: {\n                minX: 0,\n                maxX: 0,\n                minY: 0,\n                maxY: 0\n            }\n        };\n        this._config = {\n            moveAreaMarginLeft: 0,\n            moveAreaMarginRight: 0,\n            moveAreaMarginTop: 0,\n            moveAreaMarginBottom: 0,\n            FPS: 50,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1\n        };\n        this._touchDrive = new BilliardTouchDrive(el).init(this._moveStatus);\n        el.addEventListener('touchstart', function (e) {\n            _this.updateElPosition(false);\n            _this.status = 'moving';\n            _this._touchDrive.start(e);\n        });\n        el.addEventListener('touchmove', function (e) {\n            _this._touchDrive.move(e);\n            _this._updateEl(_this._moveStatus.x, _this._moveStatus.y);\n        });\n        el.addEventListener('touchend', function (e) {\n            _this.status = 'static';\n            var moveRes = _this._touchDrive.end(e);\n            //console.log(moveRes);\n            if (!!moveRes) {\n                var speed = moveRes.speed * _this._moveStatus.touchDriveCoefficient;\n                _this.drive(speed, moveRes.angle);\n            }\n        });\n    }\n\n    _createClass(BilliardElement, [{\n        key: 'getConfig',\n        value: function getConfig() {\n            return JSON.parse(JSON.stringify(this._config));\n        }\n    }, {\n        key: 'setConfig',\n        value: function setConfig() {\n            var con = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var config = this._config;\n            for (var i in con) {\n                if (!!config[i] || config[i] === 0 || config[i] === false) {\n                    config[i] = con[i];\n                }\n            }\n            this.updateElPosition();\n            this._useConfig();\n            return this;\n        }\n    }, {\n        key: '_useConfig',\n        value: function _useConfig() {\n            var config = this._config;\n            var moveStatus = this._moveStatus;\n            var limit = this._moveStatus.limit;\n            moveStatus.FPS = config.FPS;\n            moveStatus.frictionSpeed = config.frictionSpeed;\n            moveStatus.touchDriveCoefficient = config.touchDriveCoefficient;\n            limit.minX = config.moveAreaMarginLeft;\n            limit.minY = config.moveAreaMarginTop;\n            limit.maxX = moveStatus.MAX_X - config.moveAreaMarginRight;\n            limit.maxY = moveStatus.MAX_Y - config.moveAreaMarginBottom;\n            return this;\n        }\n    }, {\n        key: 'drive',\n        value: function drive(speed, angle) {\n            var _this2 = this;\n\n            if (typeof speed !== 'number' && typeof angle !== 'number') throw 'speed or angle not matching';\n            if (this.status === 'moving') return undefined;\n            this.updateElPosition(false);\n            var moveStatus = this._moveStatus;\n            moveStatus.speed = speed;\n            moveStatus.moveAngle = angle;\n            var movePath = this._getMovePath(function (res) {\n                return _this2._getNextFsMoveInfo(moveStatus);\n            });\n            this._move(movePath);\n            return this;\n        }\n    }, {\n        key: 'updateElPosition',\n        value: function updateElPosition() {\n            var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            if (this.status !== \"uninit\" && !force) return;\n            var el = this._el;\n            var s = this._moveStatus;\n            var limit = this._moveStatus.limit;\n            s.x = el.offsetLeft;\n            s.y = el.offsetTop;\n            var body = document.documentElement;\n            limit.maxX = s.MAX_X = body.clientWidth - el.offsetWidth;\n            limit.maxY = s.MAX_Y = body.clientHeight - el.offsetHeight;\n            el.style.left = \"0px\";\n            el.style.top = \"0px\";\n            this.status = \"static\";\n            this._updateEl(s.x, s.y);\n            return this;\n        }\n    }, {\n        key: '_updateEl',\n        value: function _updateEl(x, y) {\n            this._el.style[prefix] = \"translate(\" + x + \"px,\" + y + 'px)';\n            return this;\n        }\n    }, {\n        key: '_move',\n        value: function _move(animations, resolve) {\n            var _this3 = this;\n\n            var fpsTime = 1000 / this._moveStatus.FPS;\n            this.status = 'moving';\n            this._interval = setInterval(function () {\n                var coorChange = animations.pop();\n                if (!coorChange) {\n                    clearInterval(_this3._interval);\n                    _this3.status = 'static';\n                    return;\n                };\n                _this3._updateEl(coorChange.x, coorChange.y);\n            }, fpsTime);\n            return this;\n        }\n    }, {\n        key: '_getNextFsMoveInfo',\n        value: function _getNextFsMoveInfo(params) {\n            var angle = params.moveAngle;\n            var limit = params.limit;\n            var endSpeed = params.speed - params.frictionSpeed / params.FPS;\n            if (endSpeed <= 0) {\n                endSpeed = 0;\n                return;\n            };\n            var averageSpeed = (params.speed + endSpeed) / 2;\n            params.speed = endSpeed;\n            if (params.x >= limit.maxX) {\n                params.x = limit.maxX;\n                if (angle > 270) {\n                    params.moveAngle = 180 - params.moveAngle;\n                } else {\n                    params.moveAngle = 180 - params.moveAngle;\n                }\n            }\n            if (params.x <= limit.minX) {\n                params.x = limit.minX;\n                if (angle > 180) {\n                    params.moveAngle = 180 - params.moveAngle;\n                } else {\n                    params.moveAngle = 180 - params.moveAngle;\n                }\n            }\n            if (params.y >= limit.maxY) {\n                params.y = limit.maxY;\n                if (angle > 270) {\n                    params.moveAngle = 360 - params.moveAngle;\n                } else {\n                    params.moveAngle = 360 - params.moveAngle;\n                }\n            }\n            if (params.y <= limit.minY) {\n                params.y = limit.minY;\n                if (angle > 90) {\n                    params.moveAngle = 360 - params.moveAngle;\n                } else {\n                    params.moveAngle = 360 - params.moveAngle;\n                }\n            }\n            var distance = averageSpeed / params.FPS;\n            return this._getXY(params, averageSpeed, params.moveAngle);\n        }\n    }, {\n        key: '_getXY',\n        value: function _getXY(params, speed, angle) {\n            var limit = params.limit;\n            var pai = 0.017453293;\n            var distance = speed / params.FPS;\n            var y = -distance * Math.sin(angle * pai);\n            var x = distance * Math.cos(angle * pai);\n            params.x += x;\n            params.y += y;\n            params.x = params.x < limit.minX ? limit.minX : params.x;\n            params.y = params.y < limit.minY ? limit.minY : params.y;\n            params.x = params.x > limit.maxX ? limit.maxX : params.x;\n            params.y = params.y > limit.maxY ? limit.maxY : params.y;\n            return {\n                x: params.x,\n                y: params.y\n            };\n        }\n    }, {\n        key: '_getMovePath',\n        value: function _getMovePath(fn) {\n            var movePath = [];\n            for (var i = 0; i < 100000; i++) {\n                var res = fn();\n                if (!res) break;\n                movePath.push(res);\n            }\n            movePath.reverse();\n            return movePath;\n        }\n    }, {\n        key: '_getNextFsAttractInfo',\n        value: function _getNextFsAttractInfo(params) {\n            var angle = 0;\n            if (params.x > params.contentWidth) {\n                params.x = params.contentWidth;\n                angle = 180;\n                params.speed = -params.speed;\n            }\n            var endSpeed = params.speed + params.attractSpeed / params.FPS;\n            if (endSpeed <= 0) {\n                endSpeed = 0;\n                angle = 0;\n                params.speed = -params.speed;\n                return;\n            };\n            var averageSpeed = (params.speed + endSpeed) / 2;\n            params.speed = endSpeed;\n            return this._getXY(params, averageSpeed, angle);\n        }\n    }]);\n\n    return BilliardElement;\n}();\n\nBilliardElement.BilliardElement = BilliardElement;\nmodule.exports = BilliardElement;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BilliardTouchDrive = function () {\n    function BilliardTouchDrive(el) {\n        _classCallCheck(this, BilliardTouchDrive);\n\n        this._el = el;\n        this._x = 0;\n        this._y = 0;\n        this._history = [];\n        this._ALLOW_HISTORY = 3;\n    }\n\n    _createClass(BilliardTouchDrive, [{\n        key: \"init\",\n        value: function init(moveStatus) {\n            this._moveStatus = moveStatus;\n            return this;\n        }\n    }, {\n        key: \"start\",\n        value: function start(event) {\n            this._x = event.changedTouches[0].clientX;\n            this._y = event.changedTouches[0].clientY;\n        }\n    }, {\n        key: \"move\",\n        value: function move(event) {\n            event.preventDefault();\n            var x = event.changedTouches[0].clientX;\n            var y = event.changedTouches[0].clientY;\n            var changeX = x - this._x;\n            var changeY = y - this._y;\n            this._x = x;\n            this._y = y;\n            var s = this._moveStatus;\n            var limit = this._moveStatus.limit;\n            s.x += changeX;\n            s.y += changeY;\n            s.x = s.x < limit.minX ? limit.minX : s.x;\n            s.y = s.y < limit.minY ? limit.minY : s.y;\n            s.x = s.x > limit.maxX ? limit.maxX : s.x;\n            s.y = s.y > limit.maxY ? limit.maxY : s.y;\n            var res = {\n                x: x,\n                y: y,\n                timeStamp: event.timeStamp\n            };\n            var history = this._history;\n            history.push(res);\n            if (history.length > this._ALLOW_HISTORY) {\n                history.shift();\n            }\n            return this;\n        }\n    }, {\n        key: \"end\",\n        value: function end(event) {\n            var history = this._history;\n            var allowHistory = this._ALLOW_HISTORY;\n            if (history.length < allowHistory) {\n                this._history = [];\n                return false;\n            };\n            var last = history[history.length - 1];\n            var lastPreviou = history[history.length - 2];\n            var changeX = last.x - lastPreviou.x;\n            var changeY = last.y - lastPreviou.y;\n            var time = last.timeStamp - lastPreviou.timeStamp;\n            var speed = Math.sqrt(changeX * changeX + changeY * changeY) * 1000 / time;\n            if (speed < 500) {\n                this._history = [];\n                return false;\n            };\n            var pi = 3.1415926535898;\n            var angle = Math.atan2(-changeY, changeX) * 180 / pi;\n            if (angle < 0) angle = 360 + angle;\n            this._history = [];\n            return {\n                speed: speed,\n                angle: angle\n            };\n        }\n    }]);\n\n    return BilliardTouchDrive;\n}();\n\nBilliardTouchDrive.BilliardTouchDrive = BilliardTouchDrive;\nmodule.exports = BilliardTouchDrive;\n\n/***/ })\n/******/ ])));\n\n\n// WEBPACK FOOTER //\n// billiard-element.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ead3daef0ca45b3d084b","// @ts-check\nconst BilliardTouchDrive = require('./billiard-touch-drive.js');\n\nlet prefix = function () {\n    var div = document.createElement('div');\n    var cssText = '-webkit-transition:all .1s; -moz-transition:all .1s; -o-transition:all .1s; -ms-transition:all .1s; transition:all .1s;';\n    div.style.cssText = cssText;\n    var style = div.style;\n    if (style.webkitTransition) {\n        return 'WebkitTransform';\n    }\n    if (style.MozTransition) {\n        return 'MozTransform';\n    }\n    if (style.oTransition) {\n        return 'oTransform';\n    }\n    if (style.msTransition) {\n        return 'msTransform';\n    }\n    return 'transform';\n}();\n\nclass BilliardElement {\n    static create(el) {\n        return new this(el);\n    }\n    constructor(el) {\n        this._el = el;\n        el.style.position = 'fixed';\n        this._interval = null;\n        this.status = 'uninit'; // 'uninit'|'static' | 'moving'\n        this._moveStatus = {\n            x:0,\n            y:0,\n            MAX_X: 0,\n            MAX_Y: 0,\n            FPS: 50,\n            speed: 0,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1,\n            limit: {\n                minX: 0,\n                maxX: 0,\n                minY: 0,\n                maxY: 0\n            }\n        };\n        this._config = {\n            moveAreaMarginLeft: 0,\n            moveAreaMarginRight: 0,\n            moveAreaMarginTop: 0,\n            moveAreaMarginBottom: 0,\n            FPS: 50,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1,\n        };\n        this._touchDrive = (new BilliardTouchDrive(el)).init(this._moveStatus);\n        el.addEventListener('touchstart', e => {\n            this.updateElPosition(false);\n            this.status = 'moving';\n            this._touchDrive.start(e);\n        });\n        el.addEventListener('touchmove', e => {\n            this._touchDrive.move(e);\n            this._updateEl(this._moveStatus.x, this._moveStatus.y);\n        });\n        el.addEventListener('touchend', e => {\n            this.status = 'static';\n            let moveRes = this._touchDrive.end(e);\n            //console.log(moveRes);\n            if (!!moveRes) {\n                const speed = moveRes.speed * this._moveStatus.touchDriveCoefficient;\n                this.drive(speed, moveRes.angle);\n            }\n        });\n    }\n    getConfig() {\n        return JSON.parse(JSON.stringify(this._config));\n    }\n    setConfig(con = {}) {\n        let config = this._config;\n        for (let i in con) {\n            if (!!config[i] || config[i] === 0 || config[i] === false) {\n                config[i] = con[i];\n            }\n        }\n        this.updateElPosition();\n        this._useConfig();\n        return this;\n    }\n    _useConfig() {\n        const config = this._config;\n        let moveStatus = this._moveStatus;\n        let limit = this._moveStatus.limit;\n        moveStatus.FPS = config.FPS;\n        moveStatus.frictionSpeed = config.frictionSpeed;\n        moveStatus.touchDriveCoefficient = config.touchDriveCoefficient;\n        limit.minX = config.moveAreaMarginLeft;\n        limit.minY = config.moveAreaMarginTop;\n        limit.maxX = moveStatus.MAX_X - config.moveAreaMarginRight;\n        limit.maxY = moveStatus.MAX_Y - config.moveAreaMarginBottom;\n        return this;\n    }\n    drive(speed, angle) {\n        if (typeof speed !== 'number' && typeof angle !== 'number')\n            throw 'speed or angle not matching';\n        if (this.status === 'moving') return undefined;\n        this.updateElPosition(false);\n        let moveStatus = this._moveStatus;\n        moveStatus.speed = speed;\n        moveStatus.moveAngle = angle;\n        let movePath = this._getMovePath(res => {\n            return this._getNextFsMoveInfo(moveStatus);\n        });\n        this._move(movePath);\n        return this;\n    }\n    updateElPosition(force = true) {\n        if(this.status!==\"uninit\" && !force) return;\n        const el = this._el;\n        let s = this._moveStatus;\n        let limit = this._moveStatus.limit;\n        s.x = el.offsetLeft;\n        s.y = el.offsetTop;\n        const body = document.documentElement;\n        limit.maxX = s.MAX_X = body.clientWidth - el.offsetWidth;\n        limit.maxY = s.MAX_Y = body.clientHeight - el.offsetHeight;\n        el.style.left = \"0px\";\n        el.style.top = \"0px\";\n        this.status = \"static\";\n        this._updateEl(s.x, s.y);\n        return this;\n    }\n    _updateEl(x, y) {\n        this._el.style[prefix] = \"translate(\" + x + \"px,\" + y + 'px)';\n        return this;\n    }\n    _move(animations, resolve) {\n        const fpsTime = 1000 / this._moveStatus.FPS;\n        this.status = 'moving';\n        this._interval = setInterval(() => {\n            const coorChange = animations.pop();\n            if (!coorChange) {\n                clearInterval(this._interval);\n                this.status = 'static';\n                return;\n            };\n            this._updateEl(coorChange.x, coorChange.y);\n        }, fpsTime);\n        return this;\n    }\n    _getNextFsMoveInfo(params) {\n        const angle = params.moveAngle;\n        const limit = params.limit;\n        let endSpeed = params.speed - params.frictionSpeed / params.FPS;\n        if (endSpeed <= 0) {\n            endSpeed = 0;\n            return;\n        };\n        const averageSpeed = (params.speed + endSpeed) / 2;\n        params.speed = endSpeed;\n        if (params.x >= limit.maxX) {\n            params.x = limit.maxX;\n            if (angle > 270) {\n                params.moveAngle = 180 - params.moveAngle;\n            } else {\n                params.moveAngle = 180 - params.moveAngle;\n            }\n        }\n        if (params.x <= limit.minX) {\n            params.x = limit.minX;\n            if (angle > 180) {\n                params.moveAngle = 180 - params.moveAngle;\n            } else {\n                params.moveAngle = 180 - params.moveAngle;\n            }\n        }\n        if (params.y >= limit.maxY) {\n            params.y = limit.maxY;\n            if (angle > 270) {\n                params.moveAngle = 360 - params.moveAngle;\n            } else {\n                params.moveAngle = 360 - params.moveAngle;\n            }\n        }\n        if (params.y <= limit.minY) {\n            params.y = limit.minY;\n            if (angle > 90) {\n                params.moveAngle = 360 - params.moveAngle;\n            } else {\n                params.moveAngle = 360 - params.moveAngle;\n            }\n        }\n        const distance = averageSpeed / params.FPS;\n        return this._getXY(params, averageSpeed, params.moveAngle);\n    }\n    _getXY(params, speed, angle) {\n        const limit = params.limit;\n        const pai = 0.017453293;\n        const distance = speed / params.FPS;\n        const y = -distance * Math.sin(angle * pai);\n        const x = distance * Math.cos(angle * pai);\n        params.x += x;\n        params.y += y;\n        params.x = params.x < limit.minX ? limit.minX : params.x;\n        params.y = params.y < limit.minY ? limit.minY : params.y;\n        params.x = params.x > limit.maxX ? limit.maxX : params.x;\n        params.y = params.y > limit.maxY ? limit.maxY : params.y;\n        return {\n            x: params.x,\n            y: params.y\n        }\n    }\n    _getMovePath(fn) {\n        let movePath = [];\n        for (let i = 0; i < 100000; i++) {\n            const res = fn();\n            if (!res) break;\n            movePath.push(res);\n        }\n        movePath.reverse();\n        return movePath;\n    }\n    _getNextFsAttractInfo(params) {\n        let angle = 0;\n        if (params.x > params.contentWidth) {\n            params.x = params.contentWidth;\n            angle = 180;\n            params.speed = -params.speed;\n        }\n        let endSpeed = params.speed + params.attractSpeed / params.FPS;\n        if (endSpeed <= 0) {\n            endSpeed = 0;\n            angle = 0;\n            params.speed = -params.speed;\n            return;\n        };\n        const averageSpeed = (params.speed + endSpeed) / 2;\n        params.speed = endSpeed;\n        return this._getXY(params, averageSpeed, angle);\n    }\n}\n\nBilliardElement.BilliardElement = BilliardElement;\nmodule.exports = BilliardElement;\n\n\n// WEBPACK FOOTER //\n// ./src/billiard-element.js","class BilliardTouchDrive {\n    constructor(el) {\n        this._el = el;\n        this._x = 0;\n        this._y = 0;\n        this._history = [];\n        this._ALLOW_HISTORY = 3;\n    }\n    init(moveStatus) {\n        this._moveStatus = moveStatus;\n        return this;\n    }\n    start(event) {\n        this._x = event.changedTouches[0].clientX;\n        this._y = event.changedTouches[0].clientY;\n    }\n    move(event) {\n        event.preventDefault();\n        const x = event.changedTouches[0].clientX;\n        const y = event.changedTouches[0].clientY;\n        const changeX = x - this._x;\n        const changeY = y - this._y;\n        this._x = x;\n        this._y = y;\n        let s = this._moveStatus;\n        let limit = this._moveStatus.limit;\n        s.x += changeX;\n        s.y += changeY;\n        s.x = s.x < limit.minX ? limit.minX : s.x;\n        s.y = s.y < limit.minY ? limit.minY : s.y;\n        s.x = s.x > limit.maxX ? limit.maxX : s.x;\n        s.y = s.y > limit.maxY ? limit.maxY : s.y;\n        const res = {\n            x: x,\n            y: y,\n            timeStamp: event.timeStamp\n        }\n        let history = this._history;\n        history.push(res);\n        if (history.length > this._ALLOW_HISTORY) {\n            history.shift();\n        }\n        return this;\n    }\n    end(event) {\n        let history = this._history;\n        const allowHistory = this._ALLOW_HISTORY;\n        if (history.length < allowHistory) {\n            this._history = [];\n            return false;\n        };\n        const last = history[history.length - 1];\n        const lastPreviou = history[history.length - 2];\n        const changeX = last.x - lastPreviou.x;\n        const changeY = last.y - lastPreviou.y;\n        const time = last.timeStamp - lastPreviou.timeStamp;\n        let speed = Math.sqrt(changeX * changeX + changeY * changeY) * 1000 / time;\n        if (speed < 500) {\n            this._history = [];\n            return false;\n        };\n        const pi = 3.1415926535898;\n        let angle = Math.atan2(-changeY, changeX) * 180 / pi;\n        if (angle < 0) angle = 360 + angle;\n        this._history = [];\n        return {\n            speed: speed,\n            angle: angle\n        }\n    }\n}\n\nBilliardTouchDrive.BilliardTouchDrive = BilliardTouchDrive;\nmodule.exports = BilliardTouchDrive;\n\n\n// WEBPACK FOOTER //\n// ./src/billiard-touch-drive.js"],"sourceRoot":""}