{"version":3,"sources":["webpack:///billiard-element.export.min.js","webpack:///webpack/bootstrap b5d35ac636eb48057d9f","webpack:///./src/billiard-element.js","webpack:///./src/billiard-touch-drive.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","BilliardTouchDrive","prefix","div","document","createElement","style","cssText","webkitTransition","MozTransition","oTransition","msTransition","BilliardElement","el","_this","this","_el","position","_interval","status","_moveStatus","x","y","MAX_X","MAX_Y","FPS","speed","frictionSpeed","touchDriveCoefficient","limit","minX","maxX","minY","maxY","_config","moveAreaMarginLeft","moveAreaMarginRight","moveAreaMarginTop","moveAreaMarginBottom","_touchDrive","init","addEventListener","e","updateElPosition","start","move","_updateEl","moveRes","end","drive","angle","value","JSON","parse","stringify","con","arguments","undefined","config","_useConfig","moveStatus","_this2","moveAngle","movePath","_getMovePath","res","_getNextFsMoveInfo","_move","force","offsetLeft","offsetTop","body","documentElement","clientWidth","offsetWidth","clientHeight","offsetHeight","left","top","animations","resolve","_this3","fpsTime","setInterval","coorChange","pop","clearInterval","params","endSpeed","averageSpeed","_getXY","distance","Math","sin","cos","fn","push","reverse","contentWidth","attractSpeed","_x","_y","_history","_ALLOW_HISTORY","event","changedTouches","clientX","clientY","preventDefault","changeX","changeY","timeStamp","history","shift","allowHistory","last","lastPreviou","time","sqrt","atan2"],"mappings":"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","file":"billiard-element.export.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// @ts-check\nvar BilliardTouchDrive = __webpack_require__(1);\n\nvar prefix = function () {\n    var div = document.createElement('div');\n    var cssText = '-webkit-transition:all .1s; -moz-transition:all .1s; -o-transition:all .1s; -ms-transition:all .1s; transition:all .1s;';\n    div.style.cssText = cssText;\n    var style = div.style;\n    if (style.webkitTransition) {\n        return 'WebkitTransform';\n    }\n    if (style.MozTransition) {\n        return 'MozTransform';\n    }\n    if (style.oTransition) {\n        return 'oTransform';\n    }\n    if (style.msTransition) {\n        return 'msTransform';\n    }\n    return 'transform';\n}();\n\nvar BilliardElement = function () {\n    _createClass(BilliardElement, null, [{\n        key: 'create',\n        value: function create(el) {\n            return new this(el);\n        }\n    }]);\n\n    function BilliardElement(el) {\n        var _this = this;\n\n        _classCallCheck(this, BilliardElement);\n\n        this._el = el;\n        el.style.position = 'fixed';\n        this._interval = null;\n        this.status = 'uninit'; // 'uninit'|'static' | 'moving'\n        this._moveStatus = {\n            x: 0,\n            y: 0,\n            MAX_X: 0,\n            MAX_Y: 0,\n            FPS: 50,\n            speed: 0,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1,\n            limit: {\n                minX: 0,\n                maxX: 0,\n                minY: 0,\n                maxY: 0\n            }\n        };\n        this._config = {\n            moveAreaMarginLeft: 0,\n            moveAreaMarginRight: 0,\n            moveAreaMarginTop: 0,\n            moveAreaMarginBottom: 0,\n            FPS: 50,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1\n        };\n        this._touchDrive = new BilliardTouchDrive(el).init(this._moveStatus);\n        el.addEventListener('touchstart', function (e) {\n            _this.updateElPosition(false);\n            _this.status = 'moving';\n            _this._touchDrive.start(e);\n        });\n        el.addEventListener('touchmove', function (e) {\n            _this._touchDrive.move(e);\n            _this._updateEl(_this._moveStatus.x, _this._moveStatus.y);\n        });\n        el.addEventListener('touchend', function (e) {\n            _this.status = 'static';\n            var moveRes = _this._touchDrive.end(e);\n            //console.log(moveRes);\n            if (!!moveRes) {\n                var speed = moveRes.speed * _this._moveStatus.touchDriveCoefficient;\n                _this.drive(speed, moveRes.angle);\n            }\n        });\n    }\n\n    _createClass(BilliardElement, [{\n        key: 'getConfig',\n        value: function getConfig() {\n            return JSON.parse(JSON.stringify(this._config));\n        }\n    }, {\n        key: 'setConfig',\n        value: function setConfig() {\n            var con = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var config = this._config;\n            for (var i in con) {\n                if (!!config[i] || config[i] === 0 || config[i] === false) {\n                    config[i] = con[i];\n                }\n            }\n            this.updateElPosition();\n            this._useConfig();\n            return this;\n        }\n    }, {\n        key: '_useConfig',\n        value: function _useConfig() {\n            var config = this._config;\n            var moveStatus = this._moveStatus;\n            var limit = this._moveStatus.limit;\n            moveStatus.FPS = config.FPS;\n            moveStatus.frictionSpeed = config.frictionSpeed;\n            moveStatus.touchDriveCoefficient = config.touchDriveCoefficient;\n            limit.minX = config.moveAreaMarginLeft;\n            limit.minY = config.moveAreaMarginTop;\n            limit.maxX = moveStatus.MAX_X - config.moveAreaMarginRight;\n            limit.maxY = moveStatus.MAX_Y - config.moveAreaMarginBottom;\n            return this;\n        }\n    }, {\n        key: 'drive',\n        value: function drive(speed, angle) {\n            var _this2 = this;\n\n            if (typeof speed !== 'number' && typeof angle !== 'number') throw 'speed or angle not matching';\n            if (this.status === 'moving') return undefined;\n            this.updateElPosition(false);\n            var moveStatus = this._moveStatus;\n            moveStatus.speed = speed;\n            moveStatus.moveAngle = angle;\n            var movePath = this._getMovePath(function (res) {\n                return _this2._getNextFsMoveInfo(moveStatus);\n            });\n            this._move(movePath);\n            return this;\n        }\n    }, {\n        key: 'updateElPosition',\n        value: function updateElPosition() {\n            var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            if (this.status !== \"uninit\" && !force) return;\n            var el = this._el;\n            var s = this._moveStatus;\n            var limit = this._moveStatus.limit;\n            s.x = el.offsetLeft;\n            s.y = el.offsetTop;\n            var body = document.documentElement;\n            limit.maxX = s.MAX_X = body.clientWidth - el.offsetWidth;\n            limit.maxY = s.MAX_Y = body.clientHeight - el.offsetHeight;\n            el.style.left = \"0px\";\n            el.style.top = \"0px\";\n            this.status = \"static\";\n            this._updateEl(s.x, s.y);\n            return this;\n        }\n    }, {\n        key: '_updateEl',\n        value: function _updateEl(x, y) {\n            this._el.style[prefix] = \"translate(\" + x + \"px,\" + y + 'px)';\n            return this;\n        }\n    }, {\n        key: '_move',\n        value: function _move(animations, resolve) {\n            var _this3 = this;\n\n            var fpsTime = 1000 / this._moveStatus.FPS;\n            this.status = 'moving';\n            this._interval = setInterval(function () {\n                var coorChange = animations.pop();\n                if (!coorChange) {\n                    clearInterval(_this3._interval);\n                    _this3.status = 'static';\n                    return;\n                };\n                _this3._updateEl(coorChange.x, coorChange.y);\n            }, fpsTime);\n            return this;\n        }\n    }, {\n        key: '_getNextFsMoveInfo',\n        value: function _getNextFsMoveInfo(params) {\n            var angle = params.moveAngle;\n            var limit = params.limit;\n            var endSpeed = params.speed - params.frictionSpeed / params.FPS;\n            if (endSpeed <= 0) {\n                endSpeed = 0;\n                return;\n            };\n            var averageSpeed = (params.speed + endSpeed) / 2;\n            params.speed = endSpeed;\n            if (params.x >= limit.maxX) {\n                params.x = limit.maxX;\n                if (angle > 270) {\n                    params.moveAngle = 180 - params.moveAngle;\n                } else {\n                    params.moveAngle = 180 - params.moveAngle;\n                }\n            }\n            if (params.x <= limit.minX) {\n                params.x = limit.minX;\n                if (angle > 180) {\n                    params.moveAngle = 180 - params.moveAngle;\n                } else {\n                    params.moveAngle = 180 - params.moveAngle;\n                }\n            }\n            if (params.y >= limit.maxY) {\n                params.y = limit.maxY;\n                if (angle > 270) {\n                    params.moveAngle = 360 - params.moveAngle;\n                } else {\n                    params.moveAngle = 360 - params.moveAngle;\n                }\n            }\n            if (params.y <= limit.minY) {\n                params.y = limit.minY;\n                if (angle > 90) {\n                    params.moveAngle = 360 - params.moveAngle;\n                } else {\n                    params.moveAngle = 360 - params.moveAngle;\n                }\n            }\n            var distance = averageSpeed / params.FPS;\n            return this._getXY(params, averageSpeed, params.moveAngle);\n        }\n    }, {\n        key: '_getXY',\n        value: function _getXY(params, speed, angle) {\n            var limit = params.limit;\n            var pai = 0.017453293;\n            var distance = speed / params.FPS;\n            var y = -distance * Math.sin(angle * pai);\n            var x = distance * Math.cos(angle * pai);\n            params.x += x;\n            params.y += y;\n            params.x = params.x < limit.minX ? limit.minX : params.x;\n            params.y = params.y < limit.minY ? limit.minY : params.y;\n            params.x = params.x > limit.maxX ? limit.maxX : params.x;\n            params.y = params.y > limit.maxY ? limit.maxY : params.y;\n            return {\n                x: params.x,\n                y: params.y\n            };\n        }\n    }, {\n        key: '_getMovePath',\n        value: function _getMovePath(fn) {\n            var movePath = [];\n            for (var i = 0; i < 100000; i++) {\n                var res = fn();\n                if (!res) break;\n                movePath.push(res);\n            }\n            movePath.reverse();\n            return movePath;\n        }\n    }, {\n        key: '_getNextFsAttractInfo',\n        value: function _getNextFsAttractInfo(params) {\n            var angle = 0;\n            if (params.x > params.contentWidth) {\n                params.x = params.contentWidth;\n                angle = 180;\n                params.speed = -params.speed;\n            }\n            var endSpeed = params.speed + params.attractSpeed / params.FPS;\n            if (endSpeed <= 0) {\n                endSpeed = 0;\n                angle = 0;\n                params.speed = -params.speed;\n                return;\n            };\n            var averageSpeed = (params.speed + endSpeed) / 2;\n            params.speed = endSpeed;\n            return this._getXY(params, averageSpeed, angle);\n        }\n    }]);\n\n    return BilliardElement;\n}();\n\nBilliardElement.BilliardElement = BilliardElement;\nmodule.exports = BilliardElement;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BilliardTouchDrive = function () {\n    function BilliardTouchDrive(el) {\n        _classCallCheck(this, BilliardTouchDrive);\n\n        this._el = el;\n        this._x = 0;\n        this._y = 0;\n        this._history = [];\n        this._ALLOW_HISTORY = 3;\n    }\n\n    _createClass(BilliardTouchDrive, [{\n        key: \"init\",\n        value: function init(moveStatus) {\n            this._moveStatus = moveStatus;\n            return this;\n        }\n    }, {\n        key: \"start\",\n        value: function start(event) {\n            this._x = event.changedTouches[0].clientX;\n            this._y = event.changedTouches[0].clientY;\n        }\n    }, {\n        key: \"move\",\n        value: function move(event) {\n            event.preventDefault();\n            var x = event.changedTouches[0].clientX;\n            var y = event.changedTouches[0].clientY;\n            var changeX = x - this._x;\n            var changeY = y - this._y;\n            this._x = x;\n            this._y = y;\n            var s = this._moveStatus;\n            var limit = this._moveStatus.limit;\n            s.x += changeX;\n            s.y += changeY;\n            s.x = s.x < limit.minX ? limit.minX : s.x;\n            s.y = s.y < limit.minY ? limit.minY : s.y;\n            s.x = s.x > limit.maxX ? limit.maxX : s.x;\n            s.y = s.y > limit.maxY ? limit.maxY : s.y;\n            var res = {\n                x: x,\n                y: y,\n                timeStamp: event.timeStamp\n            };\n            var history = this._history;\n            history.push(res);\n            if (history.length > this._ALLOW_HISTORY) {\n                history.shift();\n            }\n            return this;\n        }\n    }, {\n        key: \"end\",\n        value: function end(event) {\n            var history = this._history;\n            var allowHistory = this._ALLOW_HISTORY;\n            if (history.length < allowHistory) {\n                this._history = [];\n                return false;\n            };\n            var last = history[history.length - 1];\n            var lastPreviou = history[history.length - 2];\n            var changeX = last.x - lastPreviou.x;\n            var changeY = last.y - lastPreviou.y;\n            var time = last.timeStamp - lastPreviou.timeStamp;\n            var speed = Math.sqrt(changeX * changeX + changeY * changeY) * 1000 / time;\n            if (speed < 500) {\n                this._history = [];\n                return false;\n            };\n            var pi = 3.1415926535898;\n            var angle = Math.atan2(-changeY, changeX) * 180 / pi;\n            if (angle < 0) angle = 360 + angle;\n            this._history = [];\n            return {\n                speed: speed,\n                angle: angle\n            };\n        }\n    }]);\n\n    return BilliardTouchDrive;\n}();\n\nBilliardTouchDrive.BilliardTouchDrive = BilliardTouchDrive;\nmodule.exports = BilliardTouchDrive;\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// billiard-element.export.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b5d35ac636eb48057d9f","// @ts-check\nconst BilliardTouchDrive = require('./billiard-touch-drive.js');\n\nlet prefix = function () {\n    var div = document.createElement('div');\n    var cssText = '-webkit-transition:all .1s; -moz-transition:all .1s; -o-transition:all .1s; -ms-transition:all .1s; transition:all .1s;';\n    div.style.cssText = cssText;\n    var style = div.style;\n    if (style.webkitTransition) {\n        return 'WebkitTransform';\n    }\n    if (style.MozTransition) {\n        return 'MozTransform';\n    }\n    if (style.oTransition) {\n        return 'oTransform';\n    }\n    if (style.msTransition) {\n        return 'msTransform';\n    }\n    return 'transform';\n}();\n\nclass BilliardElement {\n    static create(el) {\n        return new this(el);\n    }\n    constructor(el) {\n        this._el = el;\n        el.style.position = 'fixed';\n        this._interval = null;\n        this.status = 'uninit'; // 'uninit'|'static' | 'moving'\n        this._moveStatus = {\n            x:0,\n            y:0,\n            MAX_X: 0,\n            MAX_Y: 0,\n            FPS: 50,\n            speed: 0,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1,\n            limit: {\n                minX: 0,\n                maxX: 0,\n                minY: 0,\n                maxY: 0\n            }\n        };\n        this._config = {\n            moveAreaMarginLeft: 0,\n            moveAreaMarginRight: 0,\n            moveAreaMarginTop: 0,\n            moveAreaMarginBottom: 0,\n            FPS: 50,\n            frictionSpeed: 1000,\n            touchDriveCoefficient: 1,\n        };\n        this._touchDrive = (new BilliardTouchDrive(el)).init(this._moveStatus);\n        el.addEventListener('touchstart', e => {\n            this.updateElPosition(false);\n            this.status = 'moving';\n            this._touchDrive.start(e);\n        });\n        el.addEventListener('touchmove', e => {\n            this._touchDrive.move(e);\n            this._updateEl(this._moveStatus.x, this._moveStatus.y);\n        });\n        el.addEventListener('touchend', e => {\n            this.status = 'static';\n            let moveRes = this._touchDrive.end(e);\n            //console.log(moveRes);\n            if (!!moveRes) {\n                const speed = moveRes.speed * this._moveStatus.touchDriveCoefficient;\n                this.drive(speed, moveRes.angle);\n            }\n        });\n    }\n    getConfig() {\n        return JSON.parse(JSON.stringify(this._config));\n    }\n    setConfig(con = {}) {\n        let config = this._config;\n        for (let i in con) {\n            if (!!config[i] || config[i] === 0 || config[i] === false) {\n                config[i] = con[i];\n            }\n        }\n        this.updateElPosition();\n        this._useConfig();\n        return this;\n    }\n    _useConfig() {\n        const config = this._config;\n        let moveStatus = this._moveStatus;\n        let limit = this._moveStatus.limit;\n        moveStatus.FPS = config.FPS;\n        moveStatus.frictionSpeed = config.frictionSpeed;\n        moveStatus.touchDriveCoefficient = config.touchDriveCoefficient;\n        limit.minX = config.moveAreaMarginLeft;\n        limit.minY = config.moveAreaMarginTop;\n        limit.maxX = moveStatus.MAX_X - config.moveAreaMarginRight;\n        limit.maxY = moveStatus.MAX_Y - config.moveAreaMarginBottom;\n        return this;\n    }\n    drive(speed, angle) {\n        if (typeof speed !== 'number' && typeof angle !== 'number')\n            throw 'speed or angle not matching';\n        if (this.status === 'moving') return undefined;\n        this.updateElPosition(false);\n        let moveStatus = this._moveStatus;\n        moveStatus.speed = speed;\n        moveStatus.moveAngle = angle;\n        let movePath = this._getMovePath(res => {\n            return this._getNextFsMoveInfo(moveStatus);\n        });\n        this._move(movePath);\n        return this;\n    }\n    updateElPosition(force = true) {\n        if(this.status!==\"uninit\" && !force) return;\n        const el = this._el;\n        let s = this._moveStatus;\n        let limit = this._moveStatus.limit;\n        s.x = el.offsetLeft;\n        s.y = el.offsetTop;\n        const body = document.documentElement;\n        limit.maxX = s.MAX_X = body.clientWidth - el.offsetWidth;\n        limit.maxY = s.MAX_Y = body.clientHeight - el.offsetHeight;\n        el.style.left = \"0px\";\n        el.style.top = \"0px\";\n        this.status = \"static\";\n        this._updateEl(s.x, s.y);\n        return this;\n    }\n    _updateEl(x, y) {\n        this._el.style[prefix] = \"translate(\" + x + \"px,\" + y + 'px)';\n        return this;\n    }\n    _move(animations, resolve) {\n        const fpsTime = 1000 / this._moveStatus.FPS;\n        this.status = 'moving';\n        this._interval = setInterval(() => {\n            const coorChange = animations.pop();\n            if (!coorChange) {\n                clearInterval(this._interval);\n                this.status = 'static';\n                return;\n            };\n            this._updateEl(coorChange.x, coorChange.y);\n        }, fpsTime);\n        return this;\n    }\n    _getNextFsMoveInfo(params) {\n        const angle = params.moveAngle;\n        const limit = params.limit;\n        let endSpeed = params.speed - params.frictionSpeed / params.FPS;\n        if (endSpeed <= 0) {\n            endSpeed = 0;\n            return;\n        };\n        const averageSpeed = (params.speed + endSpeed) / 2;\n        params.speed = endSpeed;\n        if (params.x >= limit.maxX) {\n            params.x = limit.maxX;\n            if (angle > 270) {\n                params.moveAngle = 180 - params.moveAngle;\n            } else {\n                params.moveAngle = 180 - params.moveAngle;\n            }\n        }\n        if (params.x <= limit.minX) {\n            params.x = limit.minX;\n            if (angle > 180) {\n                params.moveAngle = 180 - params.moveAngle;\n            } else {\n                params.moveAngle = 180 - params.moveAngle;\n            }\n        }\n        if (params.y >= limit.maxY) {\n            params.y = limit.maxY;\n            if (angle > 270) {\n                params.moveAngle = 360 - params.moveAngle;\n            } else {\n                params.moveAngle = 360 - params.moveAngle;\n            }\n        }\n        if (params.y <= limit.minY) {\n            params.y = limit.minY;\n            if (angle > 90) {\n                params.moveAngle = 360 - params.moveAngle;\n            } else {\n                params.moveAngle = 360 - params.moveAngle;\n            }\n        }\n        const distance = averageSpeed / params.FPS;\n        return this._getXY(params, averageSpeed, params.moveAngle);\n    }\n    _getXY(params, speed, angle) {\n        const limit = params.limit;\n        const pai = 0.017453293;\n        const distance = speed / params.FPS;\n        const y = -distance * Math.sin(angle * pai);\n        const x = distance * Math.cos(angle * pai);\n        params.x += x;\n        params.y += y;\n        params.x = params.x < limit.minX ? limit.minX : params.x;\n        params.y = params.y < limit.minY ? limit.minY : params.y;\n        params.x = params.x > limit.maxX ? limit.maxX : params.x;\n        params.y = params.y > limit.maxY ? limit.maxY : params.y;\n        return {\n            x: params.x,\n            y: params.y\n        }\n    }\n    _getMovePath(fn) {\n        let movePath = [];\n        for (let i = 0; i < 100000; i++) {\n            const res = fn();\n            if (!res) break;\n            movePath.push(res);\n        }\n        movePath.reverse();\n        return movePath;\n    }\n    _getNextFsAttractInfo(params) {\n        let angle = 0;\n        if (params.x > params.contentWidth) {\n            params.x = params.contentWidth;\n            angle = 180;\n            params.speed = -params.speed;\n        }\n        let endSpeed = params.speed + params.attractSpeed / params.FPS;\n        if (endSpeed <= 0) {\n            endSpeed = 0;\n            angle = 0;\n            params.speed = -params.speed;\n            return;\n        };\n        const averageSpeed = (params.speed + endSpeed) / 2;\n        params.speed = endSpeed;\n        return this._getXY(params, averageSpeed, angle);\n    }\n}\n\nBilliardElement.BilliardElement = BilliardElement;\nmodule.exports = BilliardElement;\n\n\n// WEBPACK FOOTER //\n// ./src/billiard-element.js","class BilliardTouchDrive {\n    constructor(el) {\n        this._el = el;\n        this._x = 0;\n        this._y = 0;\n        this._history = [];\n        this._ALLOW_HISTORY = 3;\n    }\n    init(moveStatus) {\n        this._moveStatus = moveStatus;\n        return this;\n    }\n    start(event) {\n        this._x = event.changedTouches[0].clientX;\n        this._y = event.changedTouches[0].clientY;\n    }\n    move(event) {\n        event.preventDefault();\n        const x = event.changedTouches[0].clientX;\n        const y = event.changedTouches[0].clientY;\n        const changeX = x - this._x;\n        const changeY = y - this._y;\n        this._x = x;\n        this._y = y;\n        let s = this._moveStatus;\n        let limit = this._moveStatus.limit;\n        s.x += changeX;\n        s.y += changeY;\n        s.x = s.x < limit.minX ? limit.minX : s.x;\n        s.y = s.y < limit.minY ? limit.minY : s.y;\n        s.x = s.x > limit.maxX ? limit.maxX : s.x;\n        s.y = s.y > limit.maxY ? limit.maxY : s.y;\n        const res = {\n            x: x,\n            y: y,\n            timeStamp: event.timeStamp\n        }\n        let history = this._history;\n        history.push(res);\n        if (history.length > this._ALLOW_HISTORY) {\n            history.shift();\n        }\n        return this;\n    }\n    end(event) {\n        let history = this._history;\n        const allowHistory = this._ALLOW_HISTORY;\n        if (history.length < allowHistory) {\n            this._history = [];\n            return false;\n        };\n        const last = history[history.length - 1];\n        const lastPreviou = history[history.length - 2];\n        const changeX = last.x - lastPreviou.x;\n        const changeY = last.y - lastPreviou.y;\n        const time = last.timeStamp - lastPreviou.timeStamp;\n        let speed = Math.sqrt(changeX * changeX + changeY * changeY) * 1000 / time;\n        if (speed < 500) {\n            this._history = [];\n            return false;\n        };\n        const pi = 3.1415926535898;\n        let angle = Math.atan2(-changeY, changeX) * 180 / pi;\n        if (angle < 0) angle = 360 + angle;\n        this._history = [];\n        return {\n            speed: speed,\n            angle: angle\n        }\n    }\n}\n\nBilliardTouchDrive.BilliardTouchDrive = BilliardTouchDrive;\nmodule.exports = BilliardTouchDrive;\n\n\n// WEBPACK FOOTER //\n// ./src/billiard-touch-drive.js"],"sourceRoot":""}